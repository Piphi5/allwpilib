// Check if we are actually building for a desktop platform.
def desktop = !(project.hasProperty("onlylinuxathena") || project.hasProperty("onlylinuxraspbian")
        || project.hasProperty("onlylinuxaarch64bionic"))

// Configure the project only if we are building for a desktop platform.
if (desktop) {
    // Add project description
    description = "System identification for robot mechanisms"

    // Apply relevant plugins
    apply plugin: "c"
    apply plugin: "cpp"
    apply plugin: "visual-studio"
    apply plugin: "google-test-test-suite"
    apply plugin: "edu.wpi.first.NativeUtils"

    // Configure the NativeUtils extension
    apply from: "${rootDir}/shared/config.gradle"

    // Configure GoogleTest
    apply from: "${rootDir}/shared/googletest.gradle"

    // Generate the version number on each build.
    def wpilibVersionFileInput = file("src/generate/WPILibVersion.cpp.in")
    def wpilibVersionFileOutput = file("$buildDir/generated/cpp/WPILibVersion.cpp")

    task generateCppVersion() {
        description = 'Generates the wpilib version class'
        group = 'WPILib'

        outputs.file wpilibVersionFileOutput
        inputs.file wpilibVersionFileInput

        if (wpilibVersioning.releaseMode) {
            outputs.upToDateWhen { false }
        }

        // We follow a simple set of checks to determine whether we should generate a new version file:
        // 1. If the release type is not development, we generate a new version file
        // 2. If there is no generated version number, we generate a new version file
        // 3. If there is a generated build number, and the release type is development, then we will
        //    only generate if the publish task is run.
        doLast {
            def version = wpilibVersioning.version.get()
            println "Writing version ${version} to $wpilibVersionFileOutput"

            if (wpilibVersionFileOutput.exists()) {
                wpilibVersionFileOutput.delete()
            }
            def read = wpilibVersionFileInput.text.replace('${wpilib_version}', version)
            wpilibVersionFileOutput.write(read)
        }
    }

    gradle.taskGraph.addTaskExecutionGraphListener { graph ->
        def willPublish = graph.hasTask(publish)
        if (willPublish) {
            generateCppVersion.outputs.upToDateWhen { false }
        }
    }

    tasks.withType(CppCompile) {
        dependsOn generateCppVersion
    }

    // Configure exports configs for Windows x86 and x64 platforms.
    nativeUtils.exportsConfigs {
        sysid {
            x86ExcludeSymbols = [
                '_CT??_R0?AV_System_error',
                '_CT??_R0?AVexception',
                '_CT??_R0?AVfailure',
                '_CT??_R0?AVruntime_error',
                '_CT??_R0?AVsystem_error',
                '_CTA5?AVfailure',
                '_TI5?AVfailure',
                '_CT??_R0?AVout_of_range',
                '_CTA3?AVout_of_range',
                '_TI3?AVout_of_range',
                '_CT??_R0?AVbad_cast'
            ]
            x64ExcludeSymbols = [
                '_CT??_R0?AV_System_error',
                '_CT??_R0?AVexception',
                '_CT??_R0?AVfailure',
                '_CT??_R0?AVruntime_error',
                '_CT??_R0?AVsystem_error',
                '_CTA5?AVfailure',
                '_TI5?AVfailure',
                '_CT??_R0?AVout_of_range',
                '_CTA3?AVout_of_range',
                '_TI3?AVout_of_range',
                '_CT??_R0?AVbad_cast'
            ]
        }
    }

    // Configure the software model.
    apply from: "model.gradle"

    // Configure publishing.
    apply from: "publish.gradle"
}
